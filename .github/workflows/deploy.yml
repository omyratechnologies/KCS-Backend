name: Deploy to EC2

on:
  push:
    branches: [ main, staging ]
  workflow_dispatch:

env:
  NODE_ENV: production
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 1.2.15

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Lint code
        run: bun run lint:check

      - name: Format check
        run: bun run format:check

      - name: Run tests
        run: bun run test:ci

  build:
    needs: test
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.image.outputs.image }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Output image
        id: image
        run: echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          IMAGE: ${{ needs.build.outputs.image }}
        with:
          host: ${{ secrets.EC2_HOST }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          port: ${{ secrets.EC2_PORT || 22 }}
          envs: IMAGE
          script: |
            # Create application directory
            sudo mkdir -p /opt/kcs-backend
            cd /opt/kcs-backend

            # Create docker-compose.prod.yml if it doesn't exist
            if [ ! -f docker-compose.prod.yml ]; then
              sudo tee docker-compose.prod.yml > /dev/null <<EOF
            version: '3.8'
            
            services:
              nginx:
                image: nginx:alpine
                container_name: kcs-nginx
                ports:
                  - "80:80"
                  - "443:443"
                volumes:
                  - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro
                  - ./ssl:/etc/nginx/ssl:ro
                  - app_logs:/var/log/nginx
                depends_on:
                  - api
                  - redis
                restart: unless-stopped
                networks:
                  - kcs-network
            
              api:
                image: \${API_IMAGE}
                container_name: kcs-api
                ports:
                  - "4500:4500"
                  - "4501:4501"
                  - "40000-40100:40000-40100/udp"
                  - "40000-40100:40000-40100/tcp"
                environment:
                  - NODE_ENV=production
                  - PORT=4500
                  - JWT_SECRET=\${JWT_SECRET}
                  - OTTOMAN_BUCKET_NAME=\${OTTOMAN_BUCKET_NAME}
                  - OTTOMAN_USERNAME=\${OTTOMAN_USERNAME}
                  - OTTOMAN_PASSWORD=\${OTTOMAN_PASSWORD}
                  - OTTOMAN_CONNECTION_STRING=\${OTTOMAN_CONNECTION_STRING}
                  - REDIS_URI=redis://redis:6379
                  - AWS_ACCESS_KEY_ID=\${AWS_ACCESS_KEY_ID}
                  - AWS_ACCESS_SECRET_KEY=\${AWS_ACCESS_SECRET_KEY}
                  - AWS_REGION=\${AWS_REGION}
                  - R2_BUCKET=\${R2_BUCKET}
                  - R2_ENDPOINT=\${R2_ENDPOINT}
                  - R2_ACCESS_KEY_ID=\${R2_ACCESS_KEY_ID}
                  - R2_SECRET_ACCESS_KEY=\${R2_SECRET_ACCESS_KEY}
                  - EMAIL_PROVIDER=\${EMAIL_PROVIDER}
                  - EMAIL_USER=\${EMAIL_USER}
                  - EMAIL_PASS=\${EMAIL_PASS}
                  - MEDIASOUP_LISTEN_IP=0.0.0.0
                  - MEDIASOUP_ANNOUNCED_IP=\${MEDIASOUP_ANNOUNCED_IP:-\$(curl -s http://169.254.169.254/latest/meta-data/public-ipv4)}
                  - SOCKET_IO_PORT=4501
                depends_on:
                  - redis
                  - couchbase
                restart: unless-stopped
                networks:
                  - kcs-network
                volumes:
                  - app_logs:/app/logs
                  - app_uploads:/app/uploads
                  - app_recordings:/app/recordings
                deploy:
                  resources:
                    limits:
                      memory: 2G
                      cpus: "1.5"
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:4500/api/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
            
              redis:
                image: redis:7-alpine
                container_name: kcs-redis
                ports:
                  - "6379:6379"
                command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
                volumes:
                  - redis_data:/data
                restart: unless-stopped
                networks:
                  - kcs-network
                healthcheck:
                  test: ["CMD", "redis-cli", "ping"]
                  interval: 30s
                  timeout: 5s
                  retries: 3
            
              couchbase:
                image: couchbase:enterprise-7.2.4
                container_name: kcs-couchbase
                ports:
                  - "8091-8096:8091-8096"
                  - "11210:11210"
                environment:
                  - CLUSTER_NAME=kcs-cluster
                  - COUCHBASE_ADMINISTRATOR_USERNAME=\${OTTOMAN_USERNAME}
                  - COUCHBASE_ADMINISTRATOR_PASSWORD=\${OTTOMAN_PASSWORD}
                  - COUCHBASE_BUCKET=\${OTTOMAN_BUCKET_NAME}
                  - COUCHBASE_BUCKET_RAMSIZE=1024
                volumes:
                  - couchbase_data:/opt/couchbase/var
                  - ./init-couchbase.sh:/opt/couchbase/init-couchbase.sh:ro
                restart: unless-stopped
                networks:
                  - kcs-network
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8091/pools/default"]
                  interval: 30s
                  timeout: 10s
                  retries: 5
                  start_period: 60s
            
            volumes:
              redis_data:
                driver: local
              couchbase_data:
                driver: local
              app_logs:
                driver: local
              app_uploads:
                driver: local
              app_recordings:
                driver: local
            
            networks:
              kcs-network:
                driver: bridge
            EOF
            fi

            # Create nginx configuration if it doesn't exist
            if [ ! -f nginx.conf ]; then
              sudo tee nginx.conf > /dev/null <<EOF
            upstream api_backend {
                server api:4500;
            }
            
            upstream socket_backend {
                server api:4501;
            }
            
            server {
                listen 80;
                server_name _;
                client_max_body_size 100M;
            
                # API routes
                location /api/ {
                    proxy_pass http://api_backend;
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                    proxy_connect_timeout 60s;
                    proxy_send_timeout 60s;
                    proxy_read_timeout 60s;
                }
            
                # Socket.IO routes
                location /socket.io/ {
                    proxy_pass http://socket_backend;
                    proxy_http_version 1.1;
                    proxy_set_header Upgrade \$http_upgrade;
                    proxy_set_header Connection "upgrade";
                    proxy_set_header Host \$host;
                    proxy_set_header X-Real-IP \$remote_addr;
                    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                    proxy_set_header X-Forwarded-Proto \$scheme;
                }
            
                # Health check
                location /health {
                    proxy_pass http://api_backend/api/health;
                    access_log off;
                }
            
                # Static files and uploads
                location /uploads/ {
                    alias /app/uploads/;
                    expires 1y;
                    add_header Cache-Control "public, immutable";
                }
            }
            EOF
            fi

            # Create Couchbase initialization script
            if [ ! -f init-couchbase.sh ]; then
              sudo tee init-couchbase.sh > /dev/null <<'EOF'
            #!/bin/bash
            set -e
            
            echo "Waiting for Couchbase to start..."
            sleep 30
            
            # Initialize cluster
            /opt/couchbase/bin/couchbase-cli cluster-init \
              --cluster localhost:8091 \
              --cluster-username $COUCHBASE_ADMINISTRATOR_USERNAME \
              --cluster-password $COUCHBASE_ADMINISTRATOR_PASSWORD \
              --cluster-ramsize 1024 \
              --cluster-index-ramsize 256 \
              --services data,index,query
            
            # Create bucket
            /opt/couchbase/bin/couchbase-cli bucket-create \
              --cluster localhost:8091 \
              --username $COUCHBASE_ADMINISTRATOR_USERNAME \
              --password $COUCHBASE_ADMINISTRATOR_PASSWORD \
              --bucket $COUCHBASE_BUCKET \
              --bucket-type couchbase \
              --bucket-ramsize $COUCHBASE_BUCKET_RAMSIZE
            
            echo "Couchbase initialization complete"
            EOF
              sudo chmod +x init-couchbase.sh
            fi

            # Create environment file
            sudo tee .env.prod > /dev/null <<EOF
            # API Configuration
            API_IMAGE=$IMAGE
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            
            # Database Configuration
            OTTOMAN_BUCKET_NAME=${{ secrets.OTTOMAN_BUCKET_NAME }}
            OTTOMAN_USERNAME=${{ secrets.OTTOMAN_USERNAME }}
            OTTOMAN_PASSWORD=${{ secrets.OTTOMAN_PASSWORD }}
            OTTOMAN_CONNECTION_STRING=couchbase://couchbase:8091
            
            # AWS Configuration
            AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
            AWS_ACCESS_SECRET_KEY=${{ secrets.AWS_ACCESS_SECRET_KEY }}
            AWS_REGION=${{ secrets.AWS_REGION }}
            
            # R2 Configuration
            R2_BUCKET=${{ secrets.R2_BUCKET }}
            R2_ENDPOINT=${{ secrets.R2_ENDPOINT }}
            R2_ACCESS_KEY_ID=${{ secrets.R2_ACCESS_KEY_ID }}
            R2_SECRET_ACCESS_KEY=${{ secrets.R2_SECRET_ACCESS_KEY }}
            
            # Email Configuration
            EMAIL_PROVIDER=${{ secrets.EMAIL_PROVIDER }}
            EMAIL_USER=${{ secrets.EMAIL_USER }}
            EMAIL_PASS=${{ secrets.EMAIL_PASS }}
            
            # MediaSoup Configuration
            MEDIASOUP_ANNOUNCED_IP=${{ secrets.EC2_PUBLIC_IP }}
            EOF

            # Login to GitHub Container Registry
            echo ${{ secrets.GITHUB_TOKEN }} | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull the latest image
            sudo docker pull $IMAGE

            # Stop and remove existing containers
            sudo docker-compose -f docker-compose.prod.yml --env-file .env.prod down || true

            # Start the application
            sudo docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d

            # Clean up old images
            sudo docker image prune -f

            # Show status
            sudo docker-compose -f docker-compose.prod.yml --env-file .env.prod ps

  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Wait for deployment
        run: sleep 60

      - name: Health Check
        run: |
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Health check attempt $attempt/$max_attempts"
            
            if curl -f -s "http://${{ secrets.EC2_HOST }}/health" > /dev/null; then
              echo "✅ Application is healthy!"
              exit 0
            fi
            
            echo "❌ Health check failed, waiting 30 seconds..."
            sleep 30
            attempt=$((attempt + 1))
          done
          
          echo "❌ Health check failed after $max_attempts attempts"
          exit 1

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "🚀 Deployment successful! Application is running at http://${{ secrets.EC2_HOST }}"
          else
            echo "❌ Deployment failed or health check timeout"
          fi
